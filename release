#!/usr/bin/env bash
# shellcheck disable=SC2154
# shellcheck disable=SC2015
# ==================================================================
# release
# ==================================================================
# Release Manager - Release
#
# File:         release
# Author:       Ragdata
# Date:         07/01/2023
# License:      MIT License
# Copyright:    Copyright Â© 2022-2023 Darren Poulton (Ragdata)
# ==================================================================
# Bumps version, creates changelog, tags, and release.
# Usage:
#   ./release <arg>
# ==================================================================
# REQUIREMENTS
# ==================================================================
# Ensure the following packages are installed:
#   - git
#   - standard-version
# ==================================================================

set -eu

set -a allexport
## load .env file
#[[ -f "$BB_DIR/.env" ]] && source "$BB_DIR/.env" || source "$BB_DIR/.env.dist"
### load bb-common libraries
#if ! command -v errorExit; then
#    [[ -f "$BB_BIN/bb-common.loader" ]] && "$BB_BIN/bb-common.loader" || "$BB_DIR/src/modules/bb-common/bb-common.loader"
#fi
set +a allexport

WORKING_BRANCH="$(git branch --show-current)"
STAGING_BRANCH="$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')"
PROD_BRANCH="master"

[[ -z "${1:-}" ]] && TYPE="patch" || TYPE="";

MESSAGE=""

#FILES=(
#    "$BB_DIR/COPYRIGHT"
#    "$BB_DIR/README.md"
#    "$BB_DIR/package.json"
#)

if [ -z "$FILES" ]; then
    if [ -f ".files" ]; then
        FILES=()
        while IFS= read -r line
        do
            FILES+=("$line")
        done < ".files"
    else
        echo "ERROR :: Project Files Array Not Found!"
    fi
fi

TOOLS=(
    "git"
    "standard-version"
)

help() {
    echo
    echo "A script to release a new version of a project"
    echo
    echo "Usage:"
    echo
    echo "      ./release <arg>"
    echo
    echo "Options:"
    echo "      -P, --preview               Preview Release - branches not modified"
    echo "      -p, --prerelease <name>     Pre-Release - may optionally supply a name to be appended to the tag"
    echo "      -f, --first                 First Release"
    echo "      -a, --patch                 Patch Release - 0.0.X [default]"
    echo "      -m, --minor                 Minor Release - 0.X.0"
    echo "      -M, --major                 Major Release - X.0.0"
    echo "      -v, --version <X.X.X>       Versioned Release - version is bumped to the one you specify"
    echo
}

checkGit() {
    if [[ -n $(git status . -s) ]]; then
        echo "ERROR: Commit the staged files first, then run this command again"
        exit 1
    fi

    if [[ "$WORKING_BRANCH" != "$STAGING_BRANCH" && "$WORKING_BRANCH" != "$PATCH_STUB" ]]; then
        echo "ERROR: Please run on the master branch or patch branches"
        exit 1
    fi

    if [[ -z "$(git config --get user.email)" ]]; then
        git config --global user.name = "$USER_NAME"
        git config --global user.email = "$USER_EMAIL"
    fi
}

checkSrc() {
    if [[ ! -f "$1" && ! -d "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        exit 1
    fi
}

checkCmd() {
    if ! command -v "$1" &>/dev/null; then
        echo "ERROR: Command '$1' Not Found!"
        exit 1
    fi
}

check() {
    checkGit

    for i in "${!FILES[@]}"; do
        checkSrc "${FILES[$i]}"
    done

    for i in "${!TOOLS[@]}"; do
        checkCmd "${TOOLS[$i]}"
    done
}

bumpFile() {
    for i in "${!FILES[@]}"; do
        if [[ -f "${FILES[$i]}" ]]; then
            sed -i "s/v[[:digit:]]\+\.[[:digit:]]\+\.[[:digit:]]\+/v$1/" "${FILES[$i]}"
        fi
    done
}

bump() {
    bumpFile "$1"

    if [[ "$TYPE" != "preview" && -n $(git status . -s) ]]; then
        if [[ -z "$MESSAGE" ]]; then MESSAGE="chore(release): release $1"; else MESSAGE="$MESSAGE $1"; fi
        git add .
        git commit -m "$MESSAGE"
    fi
}

standardVersion() {
    if [[ "$1" == "preview" ]]; then
        standard-version --prerelease rc
    else
        standard-version --release-as "$1"
    fi
}

standardVersionPlus() {
    temp_branch="master-mirror"
    temp_dir="$(mktemp -d)"

    git checkout -b "$temp_branch" "$PROD_BRANCH"
    git merge --no-ff --no-edit "$STAGING_BRANCH"

    standardVersion "${1}"

    cp package.json CHANGELOG.md "$temp_dir"

    git checkout "$STAGING_BRANCH"
    git reset --hard HEAD           # undo changes from temp_branch
    mv "$temp_dir"/* .              # rewrite the changelog

    # clean up the temp stuff
    rm -rf "$temp_dir"
    git branch -D "$temp_branch"
}

release() {
    _version="$1"

    git checkout "$PROD_BRANCH"
    git merge --no-ff --no-edit "$WORKING_BRANCH"

    # create a new tag on production branch
    echo -e "Create tag v$_version\n"
    git tag "v$_version"

    # merge from patch branch to the staging branch
    # NOTE: This may break if conflicted and may require manual intervention
    if [[ "$WORKING_BRANCH" == "$PATCH_STUB" ]]; then
        git checkout "$STAGING_BRANCH"
        git merge --no-ff --no-edit "$WORKING_BRANCH"
        git branch -D "$WORKING_BRANCH"
    fi
}

main() {
    check

    if [[ "$WORKING_BRANCH" == "$STAGING_BRANCH" ]]; then
        standardVersionPlus "${TYPE}"
    else
        standardVersion "${TYPE}"
    fi

    # change heading of patch version to level 2 (a bug from `standard-version`)
    sed -i "s/^### \[/## \[/g" "$BB_DIR"/CHANGELOG.md

    _version="$(grep '"version":' package.json | sed 's/.*: "//;s/".*//')"

    echo -e "Bump version number to $_version\n"
    bump "$_version"

    if [[ "$TYPE" == "preview" ]]; then
        # undo all changes on git
        git reset --hard && git clean -fd
    else
        release "$_version"
    fi
}

options=$(getopt -l "preview,prerelease::,first,patch,minor,major,version:,help" -o "Pp::famMv:h" -a -- "$@")

eval set --"$options"

while true
do
    case $1 in
        -P|--preview)
            TYPE="preview"
            shift
            ;;
        -p|--prerelease)
            TYPE="prerelease"
            [[ -n "$2" ]] && shift 2 || shift
            ;;
        -f|--first)
            TYPE="first"
            shift
            ;;
        -a|--patch)
            TYPE="patch"
            shift
            ;;
        -m|--minor)
            TYPE="minor"
            shift
            ;;
        -M|--major)
            TYPE="major"
            shift
            ;;
        -v|--version)
            TYPE="version"
            shift 2
            ;;
        -h|--help)
            help
            exit 0
            ;;
        --)
            shift
            break
            ;;
        *)
            errorExit "release :: Invalid Argument '$1'"
            ;;
    esac
done

main
