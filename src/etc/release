#!/usr/bin/env bash
# shellcheck disable=SC2034,SC1090,SC2015
# ==================================================================
# release
# ==================================================================
# Release Manager - Automated Release & Deployment Bot
#
# File:         release
# Author:       Ragdata
# Date:         04/02/2023
# License:      MIT License
# Copyright:    Copyright Â© 2023 Darren (Ragdata) Poulton
# ==================================================================
# Release Manager Executable
# ==================================================================
exec 2>>"$RM_LOG/error"

set -e

trap 'errorHandler $? ${LINENO}' ERR
#-------------------------------------------------------------------
# INITIALIZATION
#-------------------------------------------------------------------
declare -gx RM_REPO="$PWD"

[[ -z "$RM_LIB" ]] && source "$RM_REPO/.path" || source "$RM_REPO/.path.dist"

[[ -f "$RM_LIB/rm-install" ]] && source "$RM_LIB/rm-install" || source "$RM_REPO/src/lib/rm-install"
#-------------------------------------------------------------------
# VARIABLES
#-------------------------------------------------------------------
declare -Agx PROFILE

PROFILE["STARTTIME"]="$(date +%s.%N)"

declare -agx FILES
declare -agx TOOLS

declare -gx LOGGING

declare -gx WORKING_BRANCH
declare -gx STAGING_BRANCH
declare -gx PRODUCT_BRANCH

declare -gx TMPDIR

TMPDIR="$(mktemp -d)"

declare -gx CFGDIR="$RM_OPT/cfg"
declare -gx TMPLDIR="$RM_OPT/inc/tpl"

declare -gx sfx
declare -gx _version

declare -gx TYPE
declare -gx TAG

#-------------------------------------------------------------------
# FUNCTIONS
#-------------------------------------------------------------------

help() {
	cat << EOF

Project Executable - The core functionality of Release Manager

Usage:

	release <options>

	eg:	release -t version v1.0.0

Options:

	-h, --help				Display this help information
	-u, --update			Update Release Manager
	-n, --uninstall			Uninstall Release Manager
	-t, --type				Process Release Type: (requires additional argument)
	-l, --log				Set Logging to (requires additional argument)
								- false
								- true
									- if true will accept an additional optional argument being the logfile path
										eg: release -t minor -l /var/log/myLog

	Valid "Types":

		preview				Preview Release
		prerelease			Prerelease (receives optional tertiary argument (eg: release -t prerelease alpha)
		first				First Release (system will not increment configured version number)
		patch				Patch Release (system increments third digit)
		minor				Minor Release (system increments second digit, third digit 0)
		major				Major Release (system increments first digit, second & third digits 0)
		version				Specified Version Release (version argument required - eg: release -t version 1.3.2)

	Notes:

	If you DO NOT specify a type, the system will do its best to determine the most appropriate version number
	according to your git commit logs - HOWEVER - it's not particularly smart just yet ... you may encounter glitches

	You must run this software using a ROOT ACCOUNT ONLY

EOF
}

errorHandler() {
    local errNo="${1}"
    local lineNo="${2}"

    if [[ -f "$RM_LOG/error" ]]; then
        errMsg=$(tail -1 "$RM_LOG/error")
    else
        errMsg="Unknown Error"
    fi
    if [[ $LOGGING == true ]]; then
        echoLog "ERROR: ($errNo) $errMsg on Line $lineNo"
    else
        echo "ERROR: ($errNo) $errMsg on Line $lineNo"
    fi
    exit 1
}

getConfig() {
	if [[ $LOGGING == true ]]; then
		echoLog "Configuring Release Manager" --color=gold
		echoLog "separator"
	fi

    cfgFile="$(find "$PWD" -maxdepth 1 -type f -regextype posix-egrep -iregex ".+\.(release|releaserc|versionrc)(\.json)?")"
    cfgDef="$(find "$CFGDIR" -maxdepth 1 -type f -regextype posix-egrep -iregex ".+\..*\.(rel|std)(\.json)?")"

    if [[ -n "$cfgFile" ]]; then
    	[[ $LOGGING == true ]] && echoLog "Discovered Config File: '$cfgFile'"
    	readConfig "$cfgFile"
    elif [[ -f "$cfgDef" ]]; then
    	[[ $LOGGING == true ]] && echoLog "Using Config File: '$cfgDef'"
    	readConfig "$cfgDef"
    else
    	[[ $LOGGING == true ]] && echoLog "Writing Config File: '$RM_OPT/.releaserc'"
    	defaultConfig
    	readConfig "$RM_OPT/.releaserc"
    fi

    if [[ -z "$(git config --get user.email)" ]]; then
		echo
    fi
}

readConfig() {
	[[ ! -f "$1" ]] && defaultConfig

	[[ $LOGGING == true ]] && echoLog "Reading Configuration File ..."

	local filePath="${1:-}"
	local fileName="${filePath##*/}"
	local tmpFile="$TMPDIR/$fileName"
	local extends

	declare -gx configFile

	configFile="$tmpFile"

	extends=$(yq -P '.extends' "$filePath")

	echo "$extends"
}

defaultConfig() {
	cat << EOF > "$RM_OPT/.releaserc"
{
    "id": "default",
    "prettyName": "Default",
    "version": "0.1.0",
    "extends": "angular",
    "git": {
        "user": {
            "name": "Ragdata",
            "email": "ragdata@users.noreply.github.com"
        },
        "branches": {
            "prod": "master",
            "patch": "dev/.*"
        }
    },
    "files": [
        ".releaserc",
        "README.md",
        "COPYRIGHT"
    ]
}
EOF
}

check() {
	if [[ "${#FILES[@]}" -gt 0 ]]; then
		for i in "${!FILES[@]}"; do
			checkSrc "${FILES[$i]}"
		done
	fi
}

main() {
	[[ $LOGGING == true ]] && clear

	check

	getConfig

}

#-------------------------------------------------------------------
# MAIN
#-------------------------------------------------------------------

OPTIONS=$(getopt -l "update,uninstall,type:,log::,help" -o "unt:l::h" -a -- "$@")

eval set --"$OPTIONS"

while true
do
	case $1 in
		-u|--update)
			source "$RM_LIB/rm-install"
			rmUpdate
			shift
			;;
		-n|--uninstall)
			source "$RM_LIB/rm-install"
			rmUninstall
			shift
			;;
		-t|--type)
			case $2 in
				preview)
					TYPE="preview"
					shift 2
					;;
				prerelease)
					TYPE="prerelease"
					[[ -n "$3" ]] && sfx="${3:-}"
					shift 3
					;;
				first)
					TYPE="first"
					shift 2
					;;
				patch)
					TYPE="patch"
					shift 2
					;;
				minor)
					TYPE="minor"
					shift 2
					;;
				major)
					TYPE="major"
					shift 2
					;;
				version)
					TYPE="version"
					_version="${3:-}"
					shift 3
					;;
				--)
					help
					exit 1
					;;
				*)
					errorExit "release :: Invalid Argument"
					;;
			esac
			;;
		-l|--log)
			state="${2:-}"
			if [[ -z "$state" ]]; then
				state=true
				shift
			else
				state="$2"
				shift 2
			fi
			LOGGING="$state"
			;;
		-h|--help)
			help
			exit 0
			;;
		--)
			help
			exit 1
			;;
		*)
			errorExit "release :: Invalid Argument"
			;;
	esac
done

[[ -z "$TYPE" ]] && TYPE="auto"

main

# reset all traps
trap - 0 ERR
