#!/usr/bin/env bash
# shellcheck disable=SC2154,SC2015,SC2015,SC2034,SC2094
# ==================================================================
# release-version
# ==================================================================
# Release Manager - Automated Release & Deployment Bot
#
# File:         release-version
# Author:       Ragdata
# Date:         19/01/2023
# License:      MIT License
# Copyright:    Copyright © 2022-2023 Darren Poulton (Ragdata)
# ==================================================================
# Bumps version, creates changelog, tags, and release.
# Usage:
#   ./release-version <args...>
# ==================================================================
# REQUIREMENTS
# ==================================================================
# Ensure the following packages are installed:
#   - git
#   - jq
#   - jo
#   - moreutils
#   - fx [optional]
# ==================================================================
exec 2>>"$RM_LOG/error"

set -e

trap 'errorHandler $? ${LINENO}' ERR

if [[ -f "$BB_LIB/rm-loader" ]]; then
    source "$BB_LIB/rm-loader"
elif [[ -f "$RM_LIB/functions.lib" ]]; then
    source "$RM_LIB/functions.lib"
    source "$RM_LIB/log.lib"
else
    echo "release-version :: Dependencies Not Found!"
    exit 1
fi

_version="0.1.0"

TAG=""
TYPE=""
JSON=0

LOGGING=0
logFile="release"

CFG_DIR="$RM_OPT/cfg"

TOOLS=(
    "git"
    "jq"
    "jo"
    "sponge"
)

help() {
    echo
}

checkGit() {
    echoLog "Checking Git Readiness ..."
    if [[ -n $(git status . -s) ]]; then
        echo "ERROR: Commit the staged files first, then run this command again"
        exit 1
    fi

    WORKING_BRANCH="$(git branch --show-current)"
    PRODUCT_BRANCH=$(jq -r '.git.branches.prod' "$configFile")

    if ! git branch -a | grep -q "remotes/origin/HEAD -> origin/$PRODUCT_BRANCH"; then
        rm -Rf "$PWD/.git/refs/remotes"
#        git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/"$PRODUCT_BRANCH";
    fi

    STAGING_BRANCH="$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')"


    if [[ $LOGGING -eq 1 ]]; then
        echoLog "PRODUCT BRANCH -> '$PRODUCT_BRANCH'"
        echoLog "WORKING BRANCH -> '$WORKING_BRANCH'"
        echoLog "STAGING BRANCH -> '$STAGING_BRANCH'"
        echoLog "spacer"
    fi

    if [[ "$WORKING_BRANCH" != "$STAGING_BRANCH" && ! "$WORKING_BRANCH" =~ $PATCH_REGEX ]]; then
        echo "ERROR: Please run on the master branch or patch branches"
        exit 1
    fi
}

check() {
    for i in "${!FILES[@]}"; do
        checkSrc "${FILES[$i]}"
    done

    for i in "${!TOOLS[@]}"; do
        checkCmd "${TOOLS[$i]}"
    done
}

getConfig() {
    if [[ $LOGGING -eq 1 ]]; then
        echoLog "Configuring Release-Manager" --color=gold
        echoLog "separator"
    fi

    cfgFile="$(find "$PWD" -maxdepth 1 -type f -regextype posix-egrep -iregex ".+\.(release|releaserc|versionrc)(\.json)?")"
    cfgDef="$(find "$CFG_DIR" -maxdepth 1 -type f -regextype posix-egrep -iregex ".+\..*\.(rel|std)(\.json)?")"

    if [[ -n "$cfgFile" ]]; then
        [[ $LOGGING -eq 1 ]] && echoLog "Discovered Config File: '$cfgFile'"
        readConfig "$cfgFile"
    elif [[ -f "$cfgDef" ]]; then
        [[ $LOGGING -eq 1 ]] && echoLog "Using Config File: '$cfgDef'"
        readConfig "$cfgDef"
    else
        [[ $LOGGING -eq 1 ]] && echoLog "Writing Config File: '$RM_OPT/.releaserc'"
        defaultConfig
        readConfig "$RM_OPT/.releaserc"
    fi

    if [[ -z "$(git config --get user.email)" ]]; then
        [[ $(jq '.git.user | has("name")' "$configFile") ]] && USER_NAME=$(jq '.git.user.name' "$configFile") || USER_NAME="Release-Manager"
        [[ $(jq '.git.user | has("email")' "$configFile") ]] && USER_EMAIL=$(jq '.git.user.email' "$configFile") || USER_EMAIL="rm@noreply.ragdata.dev"
        git config --global user.name = "$USER_NAME"
        git config --global user.email = "$USER_EMAIL"
        [[ $LOGGING -eq 1 ]] && echoLog "Git global user configuration set: $USER_NAME <$USER_EMAIL>"
    fi
}

readConfig() {
    [[ ! -f "$1" ]] && defaultConfig

    [[ $LOGGING -eq 1 ]] && echoLog "Reading Configuration File ..."

    local filePath="${1}"
    local fileName="${filePath##*/}"
    local tmpFile="$tmpDir/$fileName"
    local extends

    declare -gx configFile

    configFile="$tmpFile"

    extends=$(jq -r '.extends' "$filePath")

    extFile="$(find "$CFG_DIR" -maxdepth 1 -type f -regextype posix-egrep -iregex ".+\.$extends\.(rel|std)(\.json)?")"

    if [[ -n "$extFile" && -f "$extFile" ]]; then
        [[ $LOGGING -eq 1 ]] && echoLog "Configuration file extends the '$extends' standard ..."
        sudo cp "$extFile" "$tmpFile"

        CONFIG=$(jq . "$filePath")
        EXTEND=$(jq . "$extFile")

        if [[ $(echo "$CONFIG" | jq 'has("name")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.name'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.name = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("description")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.description'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.description = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("version")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.version'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.version = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("prefix")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.prefix'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.prefix = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("extends")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.extends'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.extends = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("license")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.license'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.license = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.git.user | has("name")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.git.user.name'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.git.user.name = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.git.user | has("email")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.git.user.email'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.git.user.email = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.git.branches | has("prod")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.git.branches.prod'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.git.branches.prod = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.git.branches | has("patch")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.git.branches.patch'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.git.branches.patch = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.git | has("message")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.git.message'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.git.message = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("files")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.files'); EXTEND=$(echo "$EXTEND" | jq --argjson VAR "$val" '.files = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.changelog.template | has("markdown")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.changelog.template.markdown'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.changelog.template.markdown = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.changelog.template | has("json")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.changelog.template.json'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.changelog.template.json = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.types | has("list")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.types.list'); EXTEND=$(echo "$EXTEND" | jq -r --argjson VAR "$val" '.types.list = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.types | has("logged")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.types.logged'); EXTEND=$(echo "$EXTEND" | jq -r --argjson VAR "$val" '.types.logged = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.repository | has("label")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.repository.label'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.repository.label = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.repository | has("url")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.repository.url'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.repository.url = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.author | has("name")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.author.name'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.author.name = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.author | has("email")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.author.email'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.author.email = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq '.author | has("url")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.author.url'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.author.url = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("support")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.support'); EXTEND=$(echo "$EXTEND" | jq -r --argjson VAR "$val" '.support = $VAR'); fi
        if [[ $(echo "$CONFIG" | jq 'has("homepage")') == true ]]; then val=$(echo "$CONFIG" | jq -r '.homepage'); EXTEND=$(echo "$EXTEND" | jq -r --arg VAR "$val" '.homepage = $VAR'); fi

        echo "$EXTEND" | jq . | sudo sponge "$configFile"
    else
        [[ $LOGGING -eq 1 ]] && echoLog "Configuration file does not extend a standard config"
        sudo cp "$filePath" "$configFile"
    fi

    [[ $LOGGING -eq 1 ]] && echoLog "Configuration file for current session stored at '$configFile'"
}

defaultConfig() {
    cat <<EOF > "$RM_OPT/.releaserc"
{
    "name": "default",
    "version": "0.1.0",
    "extends": "angular",
    "git": {
        "user": {
            "name": "Ragdata",
            "email": "ragdata@users.noreply.github.com"
        },
        "branches": {
            "prod": "master",
            "patch": "dev/.*"
        }
    },
    "files": [
        "package.json",
        "README.md",
        "COPYRIGHT"
    ]
}
EOF
}

getCurrentVersion() {
    local pfx

    pfx=$(jq -r '.prefix' "$configFile")

    if [[ -f "$configFile" ]] && [[ $(jq 'has("version")' "$configFile") ]]; then
        # primary source of truth - release-manager config file
        ver=$(jq -r '.version' "$configFile")
    elif [[ -f "$PWD/package.json" ]] && [[ $(jq 'has("version")' "$PWD/package.json") ]]; then
        # secondary source of truth - package.json
        ver=$(jq -r '.version' "$PWD/package.json")
    elif [[ -f "$PWD/.version" ]] && [[ -n $(cat "$PWD/.version") ]]; then
        # tertiary source of truth - .version file
        ver=$(cat "$PWD/.version")
    else
        # otherwise, iterate through configured "files" looking for a version string
        FILES=$(jq '.files' "$configFile")
        for i in "${!FILES[@]}"
        do
            if jq -e . >/dev/null 2>&1 <<< "$(cat "$PWD/${FILES[$i]}")"; then
                ver=$(jq -r '.version' "$configFile")
                break
            elif grep "(${pfx}[0-9]\.[0-9]\.[0-9](-.*)?)" "$PWD/${FILES[$i]}"; then
                ver=$(grep "(${pfx}[0-9]\.[0-9]\.[0-9](-.*)?)" "$PWD/${FILES[$i]}")
                break
            fi
        done
    fi
    if [[ -z "$ver" ]]; then
        echo "0.1.0"
    else
        echo "${ver//$pfx}"
    fi
}

getLastTag() {
    git describe --abbrev=0 --tags 2&> /dev/null
}

getNextVersion() {
    local type="${1}"
    local CURR_IFS="$IFS"
    local curr


    curr=$(getCurrentVersion)

    IFS='.'

    read -r -a VER <<< "$curr"

    case "$type" in
        patch)
            VER[2]=${VER[2]}+1
            ;;
        minor)
            VER[1]=${VER[1]}+1
            VER[2]="0"
            ;;
        major)
            VER[0]=${VER[0]}+1
            VER[1]="0"
            VER[2]="0"
            ;;
        *)
            IFS="$CURR_IFS"
            errorExit "release-version :: Unknown Bump Type '$type'"
            ;;
    esac

    NEW_VER="${VER[*]}"

    IFS="$CURR_IFS"

    echo "$NEW_VER"
}

getVersion() {
        TYPE="${1}"
        TAG="${2}"

        case "$TYPE" in
            preview)
                # version not incremented
                NEW_VER=$(getCurrentVersion)
                ;;
            prerelease)
                # depends on tag value
                if [[ $TAG =~ ([0-9]\.[0-9]\.[0-9](-.*)?) ]]; then
                    NEW_VER="${TAG,,}"
                elif [[ $TAG =~ ([A-Za-z]) ]]; then
                    NEW_VER=$(getNextVersion "patch")
                    NEW_VER="$NEW_VER-${TAG,,}"
                else
                    NEW_VER=$(getNextVersion "patch")
                    NEW_VER="$NEW_VER-rc"
                fi
                ;;
            first)
                # use current version
                NEW_VER=$(getCurrentVersion)
                ;;
            patch)
                # increment digit 3
                NEW_VER=$(getNextVersion "patch")
                ;;
            minor)
                # increment digit 2 - digit 3 = 0
                NEW_VER=$(getNextVersion "minor")
                ;;
            major)
                # increment digit 1 - digit 2 & 3 = 0
                NEW_VER=$(getNextVersion "major")
                ;;
            version)
                # use specified version
                [[ -z "$TAG" ]] && errorExit "release-version :: Release Type 'Version' Requires Tag!"
                NEW_VER="$TAG"
                ;;
        esac

        echo "$NEW_VER"
}

parseTemplate() {
    local TMPL="${1}"
    local start="${2}"
    local finish="${3}"
    local active=0

    local LF="㉿"
    local OUTPUT

    while IFS= read -r line
    do
        [[ "$line" == "$finish" && $active -eq 1 ]] && active=0
        if [[ $active -eq 1 ]]; then
            OUTPUT="$OUTPUT$LF$line"
        fi
        [[ "$line" == "$start" && $active -eq 0 ]] && active=1
    done < "$TMPL"

    echo "$OUTPUT"
}

writeChangelog() {
    local output="${1}"
    local changelog="$PWD/CHANGELOG.md"
    local OUT=()
    local OLD_IFS="$IFS"

    IFS="㉿" read -r -a OUT <<< "$output"

    [[ ! -f "$changelog" ]] && touch "$changelog"

    for i in "${!OUT[@]}"
    do
        echo "${OUT[$i]}" >> "$changelog"
    done

    IFS="$OLD_IFS"
}

changeLog() {
    _version="${1}"

    if [[ $LOGGING -eq 1 ]]; then
        echoLog "spacer"
        echoLog "Writing Changelog" --color=gold
        echoLog "separator"
    fi

    local V_PREFIX
    local REPOSITORY_LABEL
    local REPOSITORY_URL
    local AUTHOR_NAME
    local AUTHOR_EMAIL
    local AUTHOR_URL
    local ISSUES_LABEL
    local ISSUES_URL
    local HOMEPAGE
    local CONFIG

    local GIT_TAGS
    local TAGS
    local LATEST_TAG
    local PREVIOUS_TAG
    local COMMITS

    local TMPL_MD
    local TMPL_MD_HEADER
    local TMPL_MD_RELEASE
    local TMPL_MD_SECTION
    local TMPL_MD_COMMIT
    local TMPL_MD_FOOTER
    local MARKDOWN
    local MD_HEADER
    local MD_RELEASE
    local MD_SECTION
    local MD_COMMIT
    local MD_FOOTER

    local TMPL_JSON
    local JSON

    TMPL_DIR="$RM_OPT/inc/tpl"

    CONFIG=$(jq . "$configFile")



    [[ $(jq 'has("prefix")' "$filePath" &> /dev/null) ]] && V_PREFIX=$(jq '.prefix' "$configFile")
    [[ $(jq '.repository | has("url")' "$filePath" &> /dev/null) ]] && REPOSITORY_URL=$(jq '.repository.url' "$configFile")
    [[ $(jq '.repository | has("label")' "$filePath" &> /dev/null) ]] && REPOSITORY_LABEL=$(jq '.repository.label' "$configFile")
    [[ $(jq '.author | has("name")' "$filePath" &> /dev/null) ]] && AUTHOR_NAME=$(jq '.author.name' "$configFile")
    [[ $(jq '.author | has("email")' "$filePath" &> /dev/null) ]] && AUTHOR_EMAIL=$(jq '.author.email' "$configFile")
    [[ $(jq '.author | has("url")' "$filePath" &> /dev/null) ]] && AUTHOR_URL=$(jq '.author.url' "$configFile")
    [[ $(jq '.support.issues | has("label")' "$filePath" &> /dev/null) ]] && ISSUES_LABEL=$(jq '.support.issues.label' "$configFile")
    [[ $(jq '.support.issues | has("url")' "$filePath" &> /dev/null) ]] && ISSUES_URL=$(jq '.support.issues.url' "$configFile")
    [[ $(jq 'has("homepage")' "$filePath" &> /dev/null) ]] && HOMEPAGE=$(jq '.homepage' "$configFile")
    [[ $(jq '.changelog.markdown | has("template")' "$filePath" &> /dev/null) ]] && TMPL_MD="$TMPL_DIR/$(jq '.changelog.markdown.template' "$configFile")"
    [[ $(jq '.changelog.json | has("template")' "$filePath" &> /dev/null) ]] && TMPL_JSON="$TMPL_DIR/$(jq '.changelog.json.template' "$configFile")"

    [[ $LOGGING -eq 1 ]] && echoLog "Generating list of all git tags in reverse order ..."
    # list of all tags in reverse order
    GIT_TAGS=$(git tag -l --sort=-version:refname)

    # make the tags an array
    TAGS=("$GIT_TAGS")
    LATEST_TAG="${TAGS[0]}"
    PREVIOUS_TAG="${TAGS[1]}"

    if [[ -n "$PREVIOUS_TAG" && -n "$LATEST_TAG" && "${TYPE,,}" != "first" ]]; then
        [[ $LOGGING -eq 1 ]] && echoLog "Generating a log of all commits which occurred between '$PREVIOUS_TAG' and '$LATEST_TAG'"
        # get a log of commits that occurred between the two tags
        COMMITS=$(git log --pretty=format:"%H" "$PREVIOUS_TAG..$LATEST_TAG")
    else
        [[ $LOGGING -eq 1 ]] && echoLog "Generating a log of ALL commits"
        # get a log of all commits for this project
        COMMITS=$(git log --pretty=format:"%H")
    fi

    # declare template variables
    local VERSION
    local RELEASE_URL
    local RELEASE_DATE

    TMPL_MD="$RM_OPT/inc/tpl/changelog.md"
    [[ $LOGGING -eq 1 ]] && echoLog "Using Markdown template file '$TMPL_MD'"

    if [[ -f "$PWD/CHANGELOG.md" ]]; then
        echo
    else
        # parse template element 'HEADER'
        [[ $LOGGING -eq 1 ]] && echoLog "Parsing template element 'HEADER'"
        TMPL_MD_HEADER=$(parseTemplate "$TMPL_MD" "[//]: # (HEADER - START)" "[//]: # (HEADER - END)")
        # write to changelog
        [[ $LOGGING -eq 1 ]] && echoLog "Writing 'HEADER' to Changelog"
        writeChangelog "$TMPL_MD_HEADER"

        # parse template element 'RELEASE'
        [[ $LOGGING -eq 1 ]] && echoLog "Parsing template element 'RELEASE'"
        TMPL_MD_RELEASE=$(parseTemplate "$TMPL_MD" "[//]: # (RELEASE - START)" "[//]: # (RELEASE - END)")
        # set template variables
        VERSION="$V_PREFIX$_version"
        RELEASE_URL="$REPOSITORY_URL/releases/$VERSION"
        RELEASE_DATE=$(date +'%Y-%m-%d')
        # replace template variables
        TMPL_MD_RELEASE="${TMPL_MD_RELEASE//%VERSION%/"$VERSION"}"
        TMPL_MD_RELEASE="${TMPL_MD_RELEASE//%RELEASE_URL%/"$RELEASE_URL"}"
        TMPL_MD_RELEASE="${TMPL_MD_RELEASE//%RELEASE_DATE%/"$RELEASE_DATE"}"
        # write to changelog
        writeChangelog "$TMPL_MD_RELEASE"


        [[ $LOGGING -eq 1 ]] && echoLog "Parsing template element 'SECTION'"
        TMPL_MD_SECTION=$(parseTemplate "$TMPL_MD" "[//]: # (SECTION - START)" "[//]: # (SECTION - END)")
        [[ $LOGGING -eq 1 ]] && echoLog "Parsing template element 'COMMIT'"
        TMPL_MD_COMMIT=$(parseTemplate "$TMPL_MD" "[//]: # (COMMIT - START)" "[//]: # (COMMIT - END)")
        [[ $LOGGING -eq 1 ]] && echoLog "Parsing template element 'FOOTER'"
        TMPL_MD_FOOTER=$(parseTemplate "$TMPL_MD" "[//]: # (FOOTER - START)" "[//]: # (FOOTER - END)")
    fi
}

main() {
    [[ $LOGGING -eq 1 ]] && clear

    check

    [[ "$TYPE" == "preview" ]] && LOG=1;
    [[ $LOGGING -eq 1 ]] && logInit "$RM_LOG/$logFile";

    if [[ $LOGGING -eq 1 ]]; then
        echoLog "Installing Release-Manager - Changelog Generator & Packager" --color=yellow
        echoLog "line"
        echoLog "spacer"
    fi

    declare -gx WORKING_BRANCH
    declare -gx STAGING_BRANCH
    declare -gx PRODUCT_BRANCH

    declare -gx tmpDir

    tmpDir="$(mktemp -d)"

    getConfig

    checkGit


    tempBranch="mirror"
    prodBranch=$(jq -r '.git.branches.prod' "$configFile")

    # get next version
    _version=$(getVersion "$TYPE" "$TAG")

    # checkout alt branch (for safety)
    git checkout -b "$tempBranch" "$prodBranch"
    git merge --no-ff --no-edit "$STAGING_BRANCH"

    # write changelog
    changeLog "$_version"

    # bump files

    # create tag on prodBranch

#    FILES=$(jq '.files' "$configFile")
#
#    for i in "${!FILES[@]}"
#    do
#        cp "$PWD/${FILES[$i]}" "$tmpDir/${FILES[$i]}"
#    done

}

options=$(getopt -l "type:tag:,json::,log::,help,version" -o "T:t:j::l::hv" -a -- "$@")

eval set --"$options"

while true
do
    case $1 in
        -T|--type)
            TYPE="$2"
            shift;;
        -t|--tag)
            TAG="$2"
            shift;;
        -j|--json)
            if [[ -n "$2" ]]; then fileOut="$2"; shift; else fileOut="changelog.json"; fi
            JSON=1;;
        -l|--log)
            if [[ -n "$2" ]]; then logFile="$2"; shift; else logFile="release"; fi
            LOGGING=1;;
        -h|--help)
            help
            exit 0;;
        -v|--version)
            echo "$VERSION"
            exit 0;;
        --)
            break;;
        *)
            errorExit "release :: Invalid Argument";;
    esac
    shift
done

main
