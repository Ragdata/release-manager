#!/usr/bin/env bash
# shellcheck disable=SC2034
# ==================================================================
# src/lib/functions.lib
# ==================================================================
# Release Manager - Automated Release & Deployment Bot
#
# File:         src/lib/functions.lib
# Author:       Ragdata
# Date:         13/01/2023
# License:      MIT License
# Copyright:    Copyright Â© 2022-2023 Darren Poulton (Ragdata)
# ==================================================================

DEFAULT_Y="[${WHITE}Y${_0}/n]"
DEFAULT_N="[y/${WHITE}N${_0}]"
#
# RESPONSE REGEX ---------------------------------------------------
#
RESP='^[YyNn]$'
AFFIRM='^[Yy]$'
NEGAT='^[Nn]$'
#
# NETWORK REGEX ----------------------------------------------------
#
isFQDN='^[a-z0-9][a-z0-9\-]+\.[a-z0-9\.\-]+$'
isHOST='^[a-z0-9\-]+$'
isPORT='^[1-9][0-9]{2,4}$'
isIPv4='^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]?[0-9])\.?){4}$'
isIPv6='^([a-fA-F0-9]{0,4}:?){6}([a-fA-F0-9]{1,4})$'
isDOCKJOIN='^[\s]+(docker swarm join \-\-token (SWMTKN\-[^\s]+) (((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])):?([0-9]+)?))$'
isSWMKEY='^[\s]+(SWMKEY[^\s\n]+)$'
#
# OPTIONS REGEX ----------------------------------------------------
#
isOPT='^(-{1}([^=\-\s\n]+)[\s]?([^=\-\n]*))$|^(-{2}([^=\-\s\n]+)=?([^=\-\s\n]*))$'
isOPTNOVAL='^(-{1}([^=\-\s\n]))$|^(-{2}([^=\-\s\n]+))$'
isOPTVAL='^(-{1}([^=\-\s\n])\s([^=\-\s\n]+))$|^(-{2}([^=\-\s\n]+)=(.+))$'
isSOPT='^-{1}([^=\-\s\n]+)\s?([^=\-\n]*)$'
isSOPTNOVAL='^-{1}([^=\-\s\n])$'
isSOPTVAL='^-{1}([^=\-\s\n])\s([^=\-\s\n]+)$'
isLOPT='^-{2}([^=\-\s\n]+)=?([^=\-\s\n]*)$'
isLOPTNOVAL='^-{2}([^=\-\s\n]+)$'
isLOPTVAL='^-{2}([^=\-\s\n]+)=(.+)$'
#
# GENERAL REGEX ----------------------------------------------------
#
isDBNAME='^[a-z0-9\-_]+$'
isEMAIL='^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$'
isPATH='^(/[^/]*)*(/?.+(\..+))$'
isLOC='^[a-z]{2}_[A-Z]{2}.*$'
USER_PASS='^[a-zA-Z0-9-~_.,!@#$%^&*()+=]+$'
#
# RESET ------------------------------------------------------------
#
_0='\e[0m'
#
# COMBO COLOURS ----------------------------------------------------
#
DBUG='\e[1;4;34m'
DEFAULT='\e[1;39m'
BLACK='\e[1;30m'
RED='\e[1;31m'
GREEN='\e[1;32m'
GOLD='\e[33m'
YELLOW='\e[1;33m'
BLUE='\e[1;34m'
MAGENTA='\e[1;35m'
CYAN='\e[1;36m'
LGREY='\e[1;37m'
DGREY='\e[1;90m'
WHITE='\e[1;97m'
#
# COLOR FUNCTIONS --------------------------------------------------
#
# DBUG
echoDebug() { echo -e "${DBUG}${1:-}${_0}"; }
# DEFAULT
echoDefault() { echo -e "${DEFAULT}${1:-}${_0}"; }
# BLACK
echoBlack() { echo -e "${BLACK}${1:-}${_0}"; }
# RED
echoRed() { echo -e "${RED}${1:-}${_0}"; }
# GREEN
echoGreen() { echo -e "${GREEN}${1:-}${_0}"; }
# GOLD
echoGold() { echo -e "${GOLD}${1:-}${_0}"; }
# YELLOW
echoYellow() { echo -e "${YELLOW}${1:-}${_0}"; }
# BLUE
echoBlue() { echo -e "${BLUE}${1:-}${_0}"; }
# MAGENTA
echoMagenta() { echo -e "${MAGENTA}${1:-}${_0}"; }
# CYAN
echoCyan() { echo -e "${CYAN}${1:-}${_0}"; }
# LGREY
echoLgrey() { echo -e "${LGREY}${1:-}${_0}"; }
# DGREY
echoDgrey() { echo -e "${DGREY}${1:-}${_0}"; }
# WHITE
echoWhite() { echo -e "${WHITE}${1:-}${_0}"; }
#
# MESSAGE FUNCTIONS ------------------------------------------------
#
# Output red message prefixed with [!] and exit
echoError() { echoRed "[!] ${1:-}" >&2; }
# Output blue message prefixed with [=]
echoInfo() { echoBlue "[=] ${1:-}"; }
# Output green message prefixed with [+]
echoSuccess() { echoGreen "[+] ${1:-}"; }
# Output orange message prefixed with [-]
echoWarning() { echoGold "[-] ${1:-}"; }
#
# errorExit [MESSAGE] [OPTIONS]...
#
# Options:
#   -c              Set continuous mode
#   --code=[CODE]   Set exit code = CODE
#
errorExit()
{
    local msg=${1:-"Unknown Error"}

    [[ -n "$1" ]] && shift

    local cont="N"
    local code=1

    if [[ "$#" -ne 0 ]]; then
        for opt in "$@"
        do
            if [[ $opt =~ $isOPT ]]; then
                if [[ $opt =~ $isSOPTNOVAL ]]; then
                    case "${BASH_REMATCH[1]}" in
                        c)
                            cont="Y"
                            ;;
                        *)
                            echoError "errorExit :: Unknown Option '${BASH_REMATCH[1]}'"
                            exit 101
                            ;;
                    esac
                elif [[ $opt =~ $isLOPTVAL ]]; then
                    case "${BASH_REMATCH[1]}" in
                        error|code)
                            [[ "${BASH_REMATCH[2]}" =~ ^[1-9][0-9]*$ ]] && code="${BASH_REMATCH[2]}"
                            shift
                            ;;
                        *)
                            echoError "errorExit :: Unknown Option '${BASH_REMATCH[1]}'"
                            exit 101
                            ;;
                    esac
                fi
            fi
        done
    fi
    if [[ "$cont" == "Y" ]]; then
        echoRed "${msg}"
    else
        echoError "${msg}"
    fi
    exit "$code"
}
#
# file2Env
#
file2Env() {
    filePath=${1:-}
    marker=${2:'bash-bits'}

    [[ -z $filePath ]] && errorExit "file2Env :: No Filename Passed!"
    [[ ! -f $filePath ]] && errorExit "file2Env :: File '$filePath' Not Found!"

    echo "# $marker file output - start" >> /etc/environment

    while IFS= read -r line
    do
        if [[ ! "$line" =~ ^#.*$ ]]; then
            line="${line#export }"
            key="${line%=*}"
            # if neither the variable name nor the line as a whole are there already, write the line
            if ! grep -q "${key}" /etc/environment && ! grep -q "${line}" /etc/environment; then
                echo "$line" >> /etc/environment
            # if the variable name is there but the value is different, then replace with the line
            elif grep -q "${key}" /etc/environment; then
                sed -i "s/$key=.*/$line/" /etc/environment
            fi
        fi
    done < "$filePath"

    echo "# $marker file output - end" >> /etc/environment
}
#
# checkDir
#
checkDir() {
    if [[ ! -d "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        exit 1
    fi
}
#
# checkFile
#
checkFile() {
    if [[ ! -f "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        exit 1
    fi
}
#
# checkSrc
#
checkSrc() {
    if [[ ! -f "$1" && ! -d "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        exit 1
    fi
}
#
# checkCmd
#
checkCmd() {
    if ! command -v "$1" &>/dev/null; then
        echo "ERROR: Command '$1' Not Found!"
        exit 1
    fi
}
#
# what
#
what() {
    if ! which "$1" &>/dev/null; then
        echo false
    else
        echo true
    fi
}
#
# shorten
#
shorten() {
    local string="${1}"
    local substr="${2}"
    local side="${3:-l}"

    [[ "$side" == "l" ]] && echo "${string#"$substr"}" || echo "${string%"$substr"}"
}
#
# substr
#
substr() {
    local string="${1}"
    local substr="${2}"
    local side="${3:-l}"

    [[ "$side" == "l" ]] && echo "${string##"$substr"}" || echo "${string%%"$substr"}"
}
#
# strip - remove all before or after delimiter
#
strip() {
    local string="${1:-}"
    local del="${2:-/}"
    local side="${3:-l}"

    [[ "$side" == "l" ]] && echo "${string##*"$del"}" || echo "${string%%"$del"*}"
}
#
# strIndex
#
strIndex() {
    local string="${1}"
    local pos=$((2))
    local len=$((3))

    [[ -z $len ]] && echo "${string:$pos}" || echo "${string:$pos:$len}"
}
#
# trim
#
trim() {
    local string="${1}"
    local from="${2:-b}"

    if [[ "$from" == "l" ]]; then
        echo -e "${string}" | sed -e 's/^[[:space:]]*//'
    elif [[ "$from" == "r" ]]; then
        echo -e "${string}" | sed -e 's/[[:space:]]*$-//'
    else
        echo -e "${string}" | sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$-//'
    fi
}
