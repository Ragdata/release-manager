#!/usr/bin/env bash
# shellcheck disable=SC2034,SC2015,SC1090,SC2143
# ==================================================================
# lib/rm/functions
# ==================================================================
# Bash Bits - Modular Bash Library
#
# File:         lib/rm/functions
# Author:       Ragdata
# Date:         04/02/2023
# License:      MIT License
# Copyright:    Copyright Â© 2022-2023 Darren (Ragdata) Poulton
# ==================================================================
# Provides Bash Bits functions in the absence of Bash Bits
# ==================================================================

#-------------------------------------------------------------------
# VARIABLES
#-------------------------------------------------------------------
#-------------------------------------------------------------------
# PRINTABLE ELEMENTS
#-------------------------------------------------------------------
DEFAULT_Y="[${WHITE}Y${_0}/n]"
DEFAULT_N="[y/${WHITE}N${_0}]"
#-------------------------------------------------------------------
# REGEX VARIABLES
#-------------------------------------------------------------------
#
# RESPONSE REGEX ---------------------------------------------------
#
RESP='[yn]|yes|no'
AFFIRM='y|yes'
NEGAT='n|no'
#
# NETWORK REGEX ----------------------------------------------------
#
#isFQDN='^[a-z0-9][a-z0-9\-]+\.[a-z0-9\.\-]+$'
#isHOST='^[a-z0-9\-]+$'
#isPORT='^[1-9][0-9]{2,4}$'
#isIPv4='^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9]?[0-9])\.?){4}$'
#isIPv6='^([a-fA-F0-9]{0,4}:?){6}([a-fA-F0-9]{1,4})$'
#isDOCKJOIN='^[\s]+(docker swarm join \-\-token (SWMTKN\-[^\s]+) (((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])):?([0-9]+)?))$'
#isSWMKEY='^[\s]+(SWMKEY[^\s\n]+)$'
#
# GENERAL REGEX ----------------------------------------------------
#
#isVARNAME='^[A-Za-z\_][A-Za-z0-9\_]*$'
#isDBNAME='^[a-z0-9\-\_]+$'
#isEMAIL='^[A-Z0-9\.\_%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$'
#isPATH='^(/[^/]*)*(/?.+(\..+))$'
#isLOC='^[a-z]{2}_[A-Z]{2}.*$'
#USER_PASS='^[a-zA-Z0-9-~_.,!@#$%^&*()+=]+$'
#
# RESET ------------------------------------------------------------
#
_0='\e[0m'
#
# COMBO COLOURS ----------------------------------------------------
#
DBUG='\e[1;4;34m'
DEFAULT='\e[1;39m'
BLACK='\e[1;30m'
RED='\e[1;31m'
GREEN='\e[1;32m'
GOLD='\e[33m'
YELLOW='\e[1;33m'
BLUE='\e[1;34m'
MAGENTA='\e[1;35m'
CYAN='\e[1;36m'
LGREY='\e[1;37m'
DGREY='\e[1;90m'
WHITE='\e[1;97m'
#-------------------------------------------------------------------
# FUNCTIONS
#-------------------------------------------------------------------
#
# COLOR FUNCTIONS --------------------------------------------------
#
# DBUG
echoDebug() { echo -e "${DBUG}${1:-}${_0}"; }
# DEFAULT
echoDefault() { echo -e "${DEFAULT}${1:-}${_0}"; }
# BLACK
echoBlack() { echo -e "${BLACK}${1:-}${_0}"; }
# RED
echoRed() { echo -e "${RED}${1:-}${_0}"; }
# GREEN
echoGreen() { echo -e "${GREEN}${1:-}${_0}"; }
# GOLD
echoGold() { echo -e "${GOLD}${1:-}${_0}"; }
# YELLOW
echoYellow() { echo -e "${YELLOW}${1:-}${_0}"; }
# BLUE
echoBlue() { echo -e "${BLUE}${1:-}${_0}"; }
# MAGENTA
echoMagenta() { echo -e "${MAGENTA}${1:-}${_0}"; }
# CYAN
echoCyan() { echo -e "${CYAN}${1:-}${_0}"; }
# LGREY
echoLgrey() { echo -e "${LGREY}${1:-}${_0}"; }
# DGREY
echoDgrey() { echo -e "${DGREY}${1:-}${_0}"; }
# WHITE
echoWhite() { echo -e "${WHITE}${1:-}${_0}"; }
#
# MESSAGE FUNCTIONS ------------------------------------------------
#
# Output red message prefixed with [!] and exit
echoError() { echoRed "[!] ${1:-}" >&2; }
# Output blue message prefixed with [=]
echoInfo() { echoBlue "[=] ${1:-}"; }
# Output green message prefixed with [+]
echoSuccess() { echoGreen "[+] ${1:-}"; }
# Output orange message prefixed with [-]
echoWarning() { echoGold "[-] ${1:-}"; }
#
# errorExit [MESSAGE] [OPTIONS]...
#
# Options:
#   -c              Set continuous mode
#   --code=[CODE]   Set exit code = CODE
#
errorExit() {
    local msg=${1:-"Unknown Error"}

    [[ -n "$1" ]] && shift

    local cont="N"
    local code=1

    if [[ "$#" -ne 0 ]]; then
        for opt in "$@"
        do
            if [[ $opt =~ $isOPT ]]; then
                if [[ $opt =~ $isSOPTNOVAL ]]; then
                    case "${BASH_REMATCH[1]}" in
                        c)
                            cont="Y"
                            ;;
                        *)
                            echoError "errorExit :: Unknown Option '${BASH_REMATCH[1]}'"
                            exit 101
                            ;;
                    esac
                elif [[ $opt =~ $isLOPTVAL ]]; then
                    case "${BASH_REMATCH[1]}" in
                        error|code)
                            [[ "${BASH_REMATCH[2]}" =~ ^[1-9][0-9]*$ ]] && code="${BASH_REMATCH[2]}"
                            shift
                            ;;
                        *)
                            echoError "errorExit :: Unknown Option '${BASH_REMATCH[1]}'"
                            exit 101
                            ;;
                    esac
                fi
            fi
        done
    fi
    if [[ "$cont" == "Y" ]]; then
        echoRed "${msg}"
    else
        echoError "${msg}"
    fi
    exit "$code"
}
#
# file2Env
#
file2Env() {
    filePath=${1:-}
    marker=${2:-'bash-bits'}
    prefix=${3:-'declare -gx '}

    [[ -z $filePath ]] && errorExit "file2Env :: No Filename Passed!"
    [[ ! -f $filePath ]] && errorExit "file2Env :: File '$filePath' Not Found!"

	# delete lines from /etc/environment, if found
	PATTERN1="# $marker file output - start"
	PATTERN2="# $marker file output - end"
	[[ $EUID -ne 0 ]] && sudo sed -i "/$PATTERN1/,/$PATTERN2/d" /etc/environment || sed -i "/$PATTERN1/,/$PATTERN2/d" /etc/environment
	while IFS= read -r line
	do
		if [[ ! "$line" =~ ^#.*$ ]]; then
			line="${line#$prefix}"
			[[ $EUID -ne 0 ]] && echo "$line" | sudo tee -a /etc/environment &> /dev/null || echo "$line" >> /etc/environment
		fi
	done < "$filePath"
}
#
# checkDir
#
checkDir() {
    if [[ ! -d "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        exit 1
    fi
}
#
# checkFile
#
checkFile() {
    if [[ ! -f "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        exit 1
    fi
}
#
# checkSrc - checks if a particular file is accessible
#		   - accepts an additional argument:
#			   - "nofail" - function will not exit on failure
#
checkSrc() {
	local fail=true
	[[ -n "$2" && "$2" == 'nofail' ]] && fail=false
    if [[ ! -f "$1" && ! -d "$1" ]]; then
        echo "ERROR: Missing File '$1'!"
        [[ "$fail" == true ]] && exit 1
    fi
}
#
# checkCmd - checks if a particular command can be executed
#		   - accepts an additional argument:
#			   - "nofail" - function will not exit on failure
#
checkCmd() {
	local fail=true
	[[ -n "$2" && "$2" == 'nofail' ]] && fail=false
    if ! command -v "$1" &>/dev/null; then
        echo "ERROR: Command '$1' Not Found!"
        [[ "$fail" == true ]] && exit 1
    fi
}
#
# getFileName
#
getFileName() {
	echo "${1##*/}"
}
#
# getFileExt
#
getFileExt() {
	# shellcheck disable=SC2155
	local fileName="$(getFileName "$1")"
	echo "${fileName##*.}"
}
#
# getPureName
#
getPureName() {
	# shellcheck disable=SC2155
	local fileName="$(getFileName "$1")"
	echo "${fileName%%.*}"
}
#
# what
#
if ! which what &> /dev/null; then
	what() {
		if ! which "$1" &>/dev/null; then
			echo false
		else
			echo true
		fi
	}
fi
#
# shorten
#
shorten() {
    local string="${1}"
    local substr="${2}"
    local side="${3:-l}"

    [[ "$side" == "l" ]] && echo "${string#"$substr"}" || echo "${string%"$substr"}"
}
#
# substr
#
substr() {
    local string="${1}"
    local substr="${2}"
    local side="${3:-l}"

    [[ "$side" == "l" ]] && echo "${string##"$substr"}" || echo "${string%%"$substr"}"
}
#
# strip - remove all before or after delimiter
#
strip() {
    local string="${1:-}"
    local del="${2:-/}"
    local side="${3:-l}"

    [[ "$side" == "l" ]] && echo "${string##*"$del"}" || echo "${string%%"$del"*}"
}
#
# strIndex
#
strIndex() {
    local string="${1}"
    local pos=$((2))
    local len=$((3))

    [[ -z $len ]] && echo "${string:$pos}" || echo "${string:$pos:$len}"
}
#
# trim
#
trim() {
    local string="${1}"
    local from="${2:-b}"

    if [[ "$from" == "l" ]]; then
        echo -e "${string}" | sudo sed -e 's/^[[:space:]]*//'
    elif [[ "$from" == "r" ]]; then
        echo -e "${string}" | sudo sed -e 's/[[:space:]]*$-//'
    else
        echo -e "${string}" | sudo sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$-//'
    fi
}
#
# sourceFile
#
sourceFile() {
	local file="${1}"

	[[ -z "$file" ]] && errorExit "sourceFile :: Empty Argument!"
	[[ ! -f "$file" ]] && errorExit "sourceFile :: File '$file' Not Found!" || source "$file"
}
#
# require - load an array of filenames as dependencies for a script
#
require() {
	local FILES="${1}"

	[[ -z "${1}" ]] && errorExit "require :: FILES Array Not Passed!"
	[[ "${#FILES[@]}" -eq 0 ]] && errorExit "require :: FILES Array is Empty!"

	for i in "${!FILES[@]}"
	do
		sourceFile "${FILES[$i]}"
	done
}
#
# what
#
what() {
    local OPT
    local PKG="${2:-}"

    [[ -z "$PKG" ]] && errorExit "what :: No Package Passed!"

    options=$(getopt -l "quiet" -o "q" -a -- "$@")

    eval set --"$options"

    while true
    do
        case $1 in
            -q|--quiet)
                OPT="quiet"
                ;;
            --)
                break;;
            *)
                errorExit "what :: Invalid Argument!";;
        esac
        shift
    done

    if [[ "$OPT" == "quiet" ]]; then
        if ! which "$2" &>/dev/null; then echo false; else echo true; fi
    else
        if ! which "$2"; then echo false; else echo true; fi
    fi
}
#
# bashInit - reset terminal session without closing window
#
bashInit() {
    reset
    exec sudo --login --user "$USER" /bin/bash -c "cd '$PWD'; exec '$SHELL' -l"
}
#
# checkBash
#
checkBash() {
    [[ "${BASH_VERSION:0:1}" -lt 4 ]] && errorExit "This script requires a minimum Bash version of 4+!" || return 0
}
#
# checkRoot
#
checkRoot() {
    [[ "$EUID" -ne 0 ]] && errorExit "This script MUST be run as root!" || return 0
}
#
# checkCMDs - checks that the system has access to each of the commands listed in an array named TOOLS
#
checkCMDs() {
    for i in "${!TOOLS[@]}"; do
        if ! command -v "${TOOLS[$i]}" &> /dev/null; then
            errorExit "ERROR :: Command '${TOOLS[$i]}' Not Found!"
        fi
    done
}
#
# getPassword
#
getPassword() {
    local len=${1:-16}

    NUM_REGEX='^.*[0-9]+.*$'
    CAP_REGEX='^.*[A-Z]+.*$'
    SML_REGEX='^.*[a-z]+.*$'
    SYM_REGEX='^[A-Za-z0-9]+[@#$%&_+=][A-Za-z0-9]+$'

    local passwd=""

    while [[ ! $passwd =~ $NUM_REGEX ]] && [[ ! $passwd =~ $CAP_REGEX ]] && [[ ! $passwd =~ $SML_REGEX ]] && [[ ! $passwd =~ $SYM_REGEX ]]
    do
        passwd=$(tr </dev/urandom -dc 'A-Za-z0-9@#$%&_+=' | head -c"$len")
    done

    echoLog "$passwd"
}
#
# mkd
#ds
mkd() {
    sudo mkdir -p "$@" && cd "$@" || return 1
}
#
# trunc
#
trunc() {
	[[ ! -f "$1" ]] && errorExit "bb-functions/files :: File '$1' Not Found!"

	sudo truncate -s 0 "$1"
}
